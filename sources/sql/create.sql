CREATE SEQUENCE mitarbeiter_nr_gen
    MINVALUE 1
    START WITH 1
    INCREMENT BY 1
    CACHE 10;

CREATE TABLE Kino_Filiale(
    FilialeID integer PRIMARY KEY,
    LeiterName varchar(255),
    Adresse varchar(255)
);

CREATE TABLE Kinosaal(
    FilialeID integer,
    Name_ varchar(255),
    Anzahl_Spalten integer,
    Anzahl_Reihen integer,
    FOREIGN KEY (FilialeID) REFERENCES Kino_Filiale ON DELETE CASCADE,
    PRIMARY KEY (FilialeID, Name_)
);

CREATE TABLE Sitzplatz(
    FilialeID integer,
    Name_ varchar(255),
    SitzplatzNr integer,
    ReiheNr integer,
    SpalteNr integer,
    FOREIGN KEY (FilialeID, Name_) REFERENCES Kinosaal(FilialeID, Name_) ON DELETE CASCADE,
    PRIMARY KEY (Name_, SitzplatzNr, FilialeID)
);

CREATE TABLE Anzeige(
    FilialeID integer,
    Name_ varchar(255),
    Datum timestamp,
    Dauer integer, -- in Minuten angegeben
    Film_Titel varchar(255),
    FOREIGN KEY (FilialeID, Name_) REFERENCES Kinosaal(FilialeID, Name_) ON DELETE CASCADE,
    PRIMARY KEY (Name_, DATUM, FilialeID)
);

CREATE TABLE MitarbeiterIn(
    VersicherungsNr integer PRIMARY KEY,
    Name_ varchar(255) NOT NULL,
    Gehalt float,
    MitarbeiterInID integer DEFAULT mitarbeiter_nr_gen.nextval NOT NULL UNIQUE,
    CHECK ( Gehalt >= 25000 )
);

CREATE TABLE Techniker(
    VersicherungsNr integer,
    Ausbildung varchar(255),
    getroffeneTechnikerInVNR integer, -- hat_meeting Beziehung
    FilialeID integer, -- beschaeftigt
    FOREIGN KEY (FilialeID) REFERENCES Kino_Filiale ON DELETE CASCADE,
    FOREIGN KEY (VersicherungsNr) REFERENCES MitarbeiterIn ON DELETE CASCADE,
    FOREIGN KEY (getroffeneTechnikerInVNR) REFERENCES TECHNIKER ON DELETE CASCADE,
    PRIMARY KEY (VersicherungsNr)
);

CREATE TABLE Kassierer(
    VersicherungsNr integer,
    Bewertung float,
    FilialeID integer, -- beschaeftigt
    PRIMARY KEY (VersicherungsNr),
    FOREIGN KEY (VersicherungsNr) REFERENCES MitarbeiterIn ON DELETE CASCADE,
    FOREIGN KEY (FilialeID) REFERENCES Kino_Filiale ON DELETE CASCADE
);

CREATE TABLE Reinigungspersonal(
    VersicherungsNr integer,
    SchichtTageszeit NUMBER(1), -- 1 = Tagesschicht, 0 = Nachtschicht
    FilialeID integer, -- beschaeftigt
    PRIMARY KEY (VersicherungsNr),
    FOREIGN KEY (VersicherungsNr) REFERENCES MitarbeiterIn ON DELETE CASCADE,
    FOREIGN KEY (FilialeID) REFERENCES Kino_Filiale ON DELETE CASCADE
);

CREATE TABLE Kunde(
    KundenID integer GENERATED BY DEFAULT AS IDENTITY,
    Name_ varchar(255) NOT NULL,
    Age integer,
    PRIMARY KEY (KundenID)
);

CREATE TABLE Buchung(
    BuchungID integer GENERATED BY DEFAULT AS IDENTITY ,
    Preis FLOAT,
    Datum DATE, -- Datum der Buchung, nicht die Anzeige
    VersicherungsNr integer,
    KundenID integer,
    FOREIGN KEY (VersicherungsNr) REFERENCES Kassierer,
    FOREIGN KEY (KundenID) REFERENCES Kunde,
    PRIMARY KEY (BuchungID)
);

CREATE TABLE verweist_auf(
    BuchungID integer,
    SitzplatzNr integer,
    Name_ VARCHAR(255),
    FilialeID integer,
    FOREIGN KEY (BuchungID) REFERENCES Buchung(BuchungID),
    FOREIGN KEY (SitzplatzNr,Name_,FilialeID) REFERENCES Sitzplatz(SitzplatzNr,Name_,FilialeID),
    PRIMARY KEY (BuchungID)
);

CREATE TABlE betreuen(
    FilialeID integer,
    Name_ varchar(255),
    VersicherungsNr integer,
    FOREIGN KEY (FilialeID, Name_) REFERENCES Kinosaal,
    FOREIGN KEY (VersicherungsNr) REFERENCES Techniker
);

-- Trigger
-- man kann ein Kinosaal nicht hinzufÃ¼gen, falls es mehr Reihen/Spalten als Sitzplaetze gibt
CREATE OR REPLACE TRIGGER Kinosaal_Checker
    BEFORE INSERT OR UPDATE ON Kinosaal
FOR EACH ROW
DECLARE
    seatrows EXCEPTION;
    PRAGMA EXCEPTION_INIT(seatrows, -20111);
BEGIN
    BEGIN
        IF (:NEW.Anzahl_Reihen > :NEW.Anzahl_Reihen * :NEW.Anzahl_Spalten)
               OR (:NEW.Anzahl_Spalten > :NEW.Anzahl_Reihen * :NEW.Anzahl_Spalten) THEN
            raise_application_error(-20111, 'Es gibt mehr Reihen/Spalten als Sitzplaetze!');
        END IF;
    END;
END;
/

-- Views

    -- Shows first 20 movies in any movie theater
    CREATE VIEW FIRST_20_MOVIES AS
    SELECT FILM_TITEL, DATUM, DAUER, ADRESSE, NAME_
    FROM (ANZEIGE INNER JOIN KINO_FILIALE on ANZEIGE.FILIALEID = KINO_FILIALE.FILIALEID)
    ORDER BY DATUM
    FETCH FIRST 20 ROWS ONLY;

    -- Shows how many technicians with at least a degree are in a given category,
    -- and the lowest salary in their category
    CREATE VIEW LOWEST_PAID_TECHNIKER AS
    SELECT Ausbildung, COUNT(Techniker.VersicherungsNr) as Number_of_workers, MIN(Gehalt) as lowest_salary
    FROM (Techniker INNER JOIN MitarbeiterIn MI on Techniker.VersicherungsNr = MI.VersicherungsNr)
    GROUP BY Ausbildung
    HAVING Ausbildung = 'MSc' OR Ausbildung = 'BSc' OR Ausbildung = 'Fachhochschule';

commit;